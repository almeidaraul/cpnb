\documentclass[12pt, a4paper, twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amssymb,amsmath}
\usepackage{comment}
\usepackage{datetime}
\usepackage[pdfusetitle]{hyperref}
\usepackage[all]{xy}
\usepackage{graphicx}
% \addtolength{\parskip}{.5\baselineskip}

\usepackage{listings} 
\usepackage{color}
\usepackage{titlesec}
%\usepackage[landscape, left=1cm, right=1cm, top=1cm, bottom=2cm]{geometry}
\usepackage[portrait, left=0.75cm, right=0.75cm, top=1cm, bottom=2cm]{geometry}
\usepackage{changepage}

\definecolor{gray}{rgb}{0.4, 0.4, 0.4}
\setlength{\columnseprule}{0.2pt}
\setlength{\columnsep}{30pt}

\titleformat*{\section}{\Large\bfseries}
\titleformat*{\subsection}{\large\bfseries}

\newenvironment{allmono}{\ttfamily}{\par}

\lstset{
breaklines=true,
keywordstyle=\color{blue},
commentstyle=\color{gray},
basicstyle=\footnotesize,
breakatwhitespace=true,
language=C++,
%frame=single,
numbers=left,
numberstyle=\ttfamily\tiny,
numbersep=5pt,
rulecolor=\color{black},
showstringspaces=false
stringstyle=\color{blue},
tabsize=4,
basicstyle=\ttfamily\scriptsize,
literate={~} {$\sim$}{1}
}

\title{Competitive Programming Notes}
\author{Raul Almeida}


\begin{document}
\footnotesize
\twocolumn
\date{}
\maketitle

\tableofcontents

\section{Tables}
\begin{center}
\resizebox{\linewidth}{!}{
\begin{tabular}{||c c c||}
 \hline
  $n$ & not-TLE & Example \\ [0.5ex]
  \hline\hline
  $\leq [10..11]$ & $\mathcal{O}(n!), \mathcal{O}(n^6)$ & Enumerate permutations \\
  \hline
  $\leq [15..18]$ & $\mathcal{O}(2^nn^2)$ & TSP with DP \\
  \hline
  $\leq [18..22]$ & $\mathcal{O}(2^nn)$ & Bitmask DP \\
  \hline
  $\leq 100$ & $\mathcal{O}(n^4)$ & 3D DP with $\mathcal{O}(n)$ loop \\
  \hline
  $\leq 400$ & $\mathcal{O}(n^3)$ & Floyd-Warshall \\
  \hline
  $\leq 2\cdot10^3$ & $\mathcal{O}(n^2\log n)$ & 2 nested loops + tree query \\
  \hline
  $\leq 5\cdot10^4$ & $\mathcal{O}(n^2)$ & Bubble/Selection/Insertion Sort \\
  \hline
  $\leq 10^5$ & $\mathcal{O}(n\log^2n)$ & Build suffix array \\
  \hline
  $\leq 10^6$ & $\mathcal{O}(n\log n)$ & Merge Sort \\
  \hline
  $\leq 10^7$ & $\mathcal{O}(n\log\log n)$ & Totient function \\
  \hline
  $\leq 10^8$ & $\mathcal{O}(n)$ & Mathy solution often with IO bottleneck ($n \leq 10^9$) \\ [1ex]
  \hline
\end{tabular}
}
\tiny $10^8$ operations per second
\end{center}

\begin{center}
\begin{tabular}{||c c c c c||}
 \hline
  Sign & Type & Bits & Max & Digits \\ [0.5ex]
  \hline\hline
  $\pm$ & \texttt{char} & 8 & 127 & 2 \\
  \hline
  $+$ & \texttt{char} & 8 & 255 & 2 \\
  \hline
  $\pm$ & \texttt{short} & 16 & 32 767 & 4 \\
  \hline
  $+$ & \texttt{short} & 16 & 65 535 & 4 \\
  \hline
  $\pm$ & \texttt{int/long} & 32 & $~2\cdot10^9$ & 9 \\
  \hline
  $+$ & \texttt{int/long} & 32 & $~4\cdot10^9$ & 9 \\
  \hline
  $\pm$ & \texttt{long long} & 64 & $~9\cdot10^{18}$ & 18 \\
  \hline
  $+$ & \texttt{long long} & 64 & $~18\cdot10^{18}$ & 19 \\
  \hline
  $\pm$ & \texttt{\_\_int128} & 128 & $~17\cdot10^{37}$ & 38 \\
  \hline
  $+$ & \texttt{\_\_int128} & 128 & $~3\cdot10^{38}$ & 38 \\ [1ex]
  \hline
\end{tabular}
\end{center}

\section{Algorithms}
\begin{center}
\resizebox{\linewidth}{!}{
\begin{tabular}{||c c c||}
 \hline
  Algorithm & Time & Space \\ [0.5ex]
  \hline\hline
  Articulations and Bridges & $\mathcal{O}(V+E)$ & $\mathcal{O}(V+E)$ \\
  \hline
  Bellman-Ford & $\mathcal{O}(VE)$ & $\mathcal{O}(V+E)$ \\
  \hline
  Dijksta & $\mathcal{O}((V+E) \log V)$ & $\mathcal{O}(V^2)$ \\
  \hline
  Edmond Karp & $\mathcal{O}(VE^2)$ & $\mathcal{O}(V+E)$ \\
  \hline
  Euler Tour & $\mathcal{O}(E^2)$ & \\
  \hline
  Floyd Warshall & $\mathcal{O}(V^3+E)$ & $\mathcal{O}(V^2+E)$ \\
  \hline
  Graph Check & $\mathcal{O}(V+E)$ & $\mathcal{O}(V+E)$ \\
  \hline
  Kahn & $\mathcal{O}(VE)$ & $\mathcal{O}(V+E)$ \\
  \hline
  Kruskal & $\mathcal{O}(E \log V)$ & $\mathcal{O}(V+E)$ \\
  \hline
  LCA & $\mathcal{O}(N \log N)$ & $\mathcal{O}(N \log N)$ \\
  \hline
  MCBM & $\mathcal{O}(VE)$ & \\
  \hline
  Prim & $\mathcal{O}(E \log V)$ & $\mathcal{O}(V+E)$ \\
  \hline
  Tarjan & $\mathcal{O}(V+E)$ & $\mathcal{O}(V+E)$ \\
  \hline
  Extended Euclid & $\mathcal{O}(\log \min(a, b))$ & $\mathcal{O}(1)$ \\
  \hline
  Floyd (cycle) & $\mathcal{O}(V)$ & $\mathcal{O}(1)$ \\
  \hline
  Prime Fac. w/ Opt. Trial Div. & $\mathcal{O}(\pi(\sqrt{n}))$ & $\mathcal{O}(n)$ \\
  \hline
  Sieve of Eratosthenes & $\mathcal{O}(n \log \log n)$ & $\mathcal{O}(n)$ \\
  \hline
  Binary Search & $\mathcal{O}(\log N)$ & \\
  \hline
  Coordinate Compression & $\mathcal{O}(N \log N)$ & \\
  \hline
  KMP & $\mathcal{O}(N)$ & \\
  \hline
  MUF & $\mathcal{O}(AM)$ & $\mathcal{O}(N)$ \\
  \hline
  Bottom-Up SegTree & $\mathcal{O}(\log N)$ & $\mathcal{O}(N)$ \\ [1ex]
  \hline
\end{tabular}
}
{\tiny $A$: Ackermann function}
\end{center}


\subsection{Graph}
\subsubsection{Edmond Karp MaxFlow}
Ford-Fulkerson's method with BFS $\to$ $\mathcal{O}(VE)$ BFS calls, $\mathcal{O}(E)$ per BFS

\textbf{Vertex weights:} vertex $V$ has a weight, create vertices $V_{in}$ (receives all in-edges of $V$) and $V_{out}$ (has all out-edges of $V$) and edge $\{V_{in}, V_{out}\}$ with the weight from $V$

\textbf{MinCut:} run EdmondKarp; $S-T$ sets are: all $V$ that you can reach from the source with edges of positive residual capacity and all other $V$

\textbf{MultiSource/MultiSink:} create a super source with infinite capacity pointing to all sources, analogous for sinks

\textbf{Max Cardinality Bipartite Matching:} use capacity 1 on all edges and apply the multi-source and multi-sink strategies

\subsubsection{Euler Tour}
Find the closest neighbor that has a path back to the current vertex to build an euler tour

\textbf{Euler path:} visits each edge once

\textbf{Tour/cycle/circuit} euler path that starts and ends at same node

\textbf{Undirected and has path:} every vertex has even degree or two have odd degree

\textbf{Undirected and has circuit:} every vertex has even degree

\textbf{Directed and has path:} $\delta^{+}(v) - \delta^{-}(v) = 1$ for at most one $v$, $= -1$ for at most one $v$, $= 0$ for all other $v$

\textbf{Directed and has circuit:} $\delta^{+}(v) = \delta^{-}(v) \forall v \in V$

\subsubsection{Floyd Warshall}
Also works for SSSP (V <= 400)

\textbf{Printing path:} \texttt{p[i][j]} set to \texttt{i} (last node that appears before \texttt{j} on the path), then \texttt{p[i][j] = p[k][j]} on update.

\textbf{Transitive Closure:} weight is boolean (init as \texttt{1} if there's an edge), update with bitwise OR

\textbf{Minimax/Maximin:} \texttt{w[i][j]} will be \texttt{min(w[i][j], max(w[i][k], w[k][j]))}

\textbf{Finding negative/cheapest cycle:} init \texttt{w[i][i] = inf}; \texttt{run()}; any \texttt{w[i][i] != inf} is a cycle and the smallest is the cheapest; any \texttt{w[i][i] < 0} is negative cycle

This can also be used for finding SCCs (check with transitive closure)

\subsubsection{Kahn's Topological Sort}
Particular order (alphabetical)

\subsubsection{Kruskal}
Order edges by increasing weight, then use a MUF to know if each edge is useful (if it connects two previously disconnected vertices)

\textbf{Min Span Subgraph:} previously process fixed edges

\textbf{Min Span Forest:} count number of sets on the MUF

\textbf{2nd Best MST:} run kruskal; for each chosen edge, flag it as unavailable and run it without using that edge ($O(VE)$)

\textbf{Minimax:} max edge weight on the MST (maximin: min)

\subsubsection{Lowest Common Ancestor}
Binary lift to binary search the LCA or Euler Path

\subsubsection{Max Cardinality Bipartite Matching}
Jump from free to matched edges until you've used them all

\subsubsection{Prim's Algorithm}
Take smallest edge that leads to vertex $v$

\subsubsection{Tarjan}
A node can reach any other node in its own SCC (DFS + stack)

\subsubsection{Kosaraju}
Get topological sort of a graph and then run DFS on the transposed graph following this topological sort.

Let $C$ and $C'$ be two strongly connected components in the graph $G$. If there is an edge $\{C, C'\}$, then after computing \texttt{tout} and \texttt{tin} in a DFS, \texttt{tout[C] > tout[C']}. Proof:
\begin{itemize}
  \item If \texttt{tin[C] < tin[C']}, $C$ shows up first in the DFS, and since there is an edge to $C'$, it will be in $C$'s subtree in the DFS tree; so \texttt{tout[C] > tout[C']}
  \item If \texttt{tin[C] > tin[C']}, $C'$ shows up first, but since it has no path to $C$, $C$ will show up later and then have a greater \texttt{tout} value.
\end{itemize}

So when you do DFS on the transposed graph following topological sort, you will start on the root vertex (because it'll have the largest \texttt{tout} value), and only be able to visit the nodes in its SCC (because the edges that would lead to other SCCs doesn't exist in the transposed graph).

Remember that you have to "disable" the vertices in already processed SCCs.

\subsection{Math}
\subsection{Series Identities}

$$\sum_{i=1}^{n} i^{2} = \frac{n(n+1)(2n+1)}{6}  \qquad  \sum_{i=1}^{n} i^{3} = \frac{n^{2}(n+1)^{2}}{4} = \left(\sum_{i=1}^n i\right)^2$$

$$ g_k(n) = \sum_{i=1}^n i^k = \frac{1}{k+1} \left( n^{k+1} + \sum_{j=1}^k \binom{k+1}{j+1} (-1)^{j+1} g_{k-j}(n) \right) $$

$$\sum_{i=0}^{n} ic^{i} = \frac{nc^{n+2} - (n+1)c^{n+1} + c}{(c-1)^{2}}, \quad c \neq 1$$

$$\sum_{i=0}^{\infty} ic^{i} = \frac{c}{(1-c)^{2}}, \quad |c| < 1$$

\subsection{Binomial Identities}

$$
\binom{n}{k} = \frac{n}{k}\binom{n-1}{k-1}
$$
$$
\binom{n-1}{k} - \binom{n-1}{k-1} = \frac{n - 2k}{k} \binom{n}{k}
$$
$$
\binom{n}{h}\binom{n-h}{k} = \binom{n}{k}\binom{n-k}{h}
$$
$$
\binom{n}{k} = \frac{n+1-k}{k} \binom{n}{k-1}
$$
$$
\sum_{k = 0}^n k\binom{n}{k} = n 2^{n-1}
$$
$$
\sum_{k = 0}^n k^2 \binom{n}{k} = (n + n^2)2^{n-2}
$$
$$
\sum_{j = 0}^k\binom{m}{j} \binom{n-m}{k-j} = \binom{n}{k}
$$
$$
\sum_{j = 0}^m \binom{m}{j}^2 = \binom{2m}{m}
$$
$$
\sum_{m = 0}^n \binom{m}{j} \binom{n-m}{k-j} = \binom{n+1}{k+1}
$$
$$
\sum_{m = k}^n \binom{m}{k} = \binom{n+1}{k+1}
$$
$$
\sum_{r = 0}^m \binom{n+r}{r} = \binom{n+m+1}{m}
$$
$$
\sum_{k=0}^{\lfloor n/2 \rfloor} \binom{n-k}{k} = \text{Fib}(n+1)
$$
$$
(x + y)^{n} = \sum_{k=0}^{n} \binom{n}{k} x^{n-k} y^{k}
$$
$$
(1 + x)^{n} = \sum_{k=0}^{n} \binom{n}{k} x^{k}
$$
$$
2\sum_{i = L}^R \binom{n}{i} - \binom{n}{L} - \binom{n}{R} = \sum_{i = L+1}^R \binom{n+1}{i}
$$

\subsection{Taking modulo at the exponent}

If $a$ and $m$ are coprime, then

$$ a^n \equiv a^{n \text{ mod } \varphi(m)} \quad (\text{mod } m) $$

Generally, if $n \geq \log_2 m$, then

$$ a^n \equiv a^{\varphi(m) + [n \text{ mod } \varphi(m)]} \quad (\text{mod } m) $$

\subsection{Prime counting function - \texorpdfstring{$\pi(x)$}{}} The prime counting function is asymptotic to $\frac{x}{\log x}$, by the prime number theorem.

\

\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
  x&10&$10^2$&$10^3$&$10^4$\\ \hline
  $\pi(x)$& 4 & 25 & 168 & 1\,229 \\ \hline
  x&$10^5$&$10^6$&$10^7$&$10^8$\\ \hline
  $\pi(x)$& 9\,592 & 78\,498 & 664\,579 & 5\,761\,455\\ \hline
\end{tabular}

\

\subsection{Some Primes}

999999937 $\quad$ 1000000007 $\quad$ 1000000009 \\
1000000021 $\quad$ 1000000033 $10^{18} - 11 \quad\quad 10^{18} + 3$ \\
$2305843009213693951 = 2^{61} - 1$

\subsubsection{Binomial}
$X$ is the number of successes in a sequence of $n$ independent experiments.  $P(X = k) = \binom{n}{k}\,p^{k}(1-p)^{n-k}$, and $E[X] = np$ and $Var(X) = np(1-p)$.


\subsubsection{Trigonometry}
$\sin^2\theta + \cos^2\theta = 1$, $\sin = \frac{opo}{hip}$, $\cos = \frac{adj}{hip}$, $\tan = \frac{opo}{adj}$. $\sin \theta = x \to \arcsin x = \theta$.

$\alpha$ degrees to $x$ rd: $\alpha = \frac{180x}{\pi}$

\subsubsection{Multiples of $\textrm{gcd}(A, B)$ that are $\in [0, A)$}
Let $A, B > 0$, $g = \textrm{GCD}(A, B)$, $A = ag$ and $B = bg$.

$a$ integers
$(0\times B) \% A,\; (1\times B) \% A,\; (2\times B) \% A \dotsc ((a-1)\times B) \% A$
correspond to each multiple of $g$ between $0$ and $A-1$ (inclusive); note that they
are all unique.

\subsubsection{Expected Value}
Avg value of event. For each event, add to the sum the probability of an event times the value of $X$ in that event
$\mathbb{E}(X) = \sum_{\omega \in \Omega} (P(\omega)\times X(\omega))$

Another way of looking at it:

$\mathbb{E}(X) = \sum_{i=1}^{M} (i \times P(X=i))$

Since in the expanded version of this sum $P(X=i)$ will appear $i$ times, you're also calculating for each $i$ the probability that $X \geq i$ ($P(x=M)$ will appear $M$ times, once for each $i$; $P(x=1)$ will appear exactly once, for $i=1$; and so on). So

$\mathbb{E}(X) = \sum_{i=1}^{M} (i \times P(X=i)) = \sum_{i=1}^{M} P(X \geq i)$

\subsubsection{Combination}
A combination ${}_nC_k = \binom{n}{k}$ ($n$ \textit{chooses} $k$) refers to selecting $k$ objects from a collection of $n$ where the order of choice doesn't matter.

\textbf{Without repetition:} can't choose an element twice. $\binom{n}{k} = \frac{n!}{r!(n-k)!}$

\textbf{With repetition:} elements may be chosen more than once. $\binom{n}{k} = \frac{(k+n-1)!}{k!(n-1)!}$

\subsubsection{Permutation}
A permutation ${}_nP_k$ refers to selecting $k$ objects from a collection of $n$ where the order of choice matters.

\textbf{With repetition:} elements may be chosen more than once. ${}_nP_k = n^k$

\textbf{Without repetition:} can't choose an element twice. ${}_nP_k = \frac{n!}{(n-k)!}$

\subsection{Paradigm}
\subsubsection{Reminder: \texttt{lower\_} and \texttt{upper\_bound}}
\begin{itemize}
  \item \textbf{Last element $\leq x$:} \texttt{upper\_bound - 1}
  \item \textbf{First element $\geq x$:} \texttt{lower\_bound}
  \item \textbf{\texttt{upper\_bound}:} first element $> x$
  \item \textbf{\texttt{lower\_bound}:} first element $>= x$
\end{itemize}
\subsubsection{Coordinate Compression}
Normalize vector access; can also be done with map/set but high constant

\subsection{String}
\subsubsection{Suffix Array}
To find whether $p$ is a substring of $s$ (and where this ocurrence starts), you can build the suffix array $A$ of $s$. Since $A$ is sorted, you can binary search for $p$ as a prefix of all suffixes of $s$. \textbf{Complexity (besides construction):} $\mathcal{O}(\left|p\right|\log(\left|s\right|))$.

\subsubsection{Prefix Function (KMP)}
To find ocurrences of \texttt{s} in \texttt{t}, use the string \texttt{s+\%+t}, then look for \texttt{pi[i] = s.length()} on the "\texttt{t} side"

\subsubsection{Hash}
Let $h_{i..j} = \textrm{hash}(s_{i..j})$.

$h_{i..j}\times p^i = h_{0..j} - h_{0..i-1}$. Instead of finding the multiplicative inverse of $p^i$, you can multiply this term by $p^{n-i}$ (so every hash is compared multiplied by $p^n$).

\section{Emergency2}
%\begin{allmono}
\noindent
\textbf{Pre-submit}

\noindent
Write a few simple test cases if sample is not enough.

\noindent
Are time limits close? If so, generate max cases.

\noindent
Is the memory usage fine?

\noindent
Could anything overflow?

\noindent
Make sure to submit the right file (check the filename you're editing).

\noindent
\textbf{Wrong answer}

\noindent
Print your solution and debug output!

\noindent
Are you clearing all data structures between test cases?

\noindent
Can your algorithm handle the whole range of input?

\noindent
Read the full problem statement again.

\noindent
Do you handle all corner cases correctly?

\noindent
Have you understood the problem correctly?

\noindent
Any uninitialized variables?

\noindent
Any overflows?

\noindent
Confusing \texttt{N} and \texttt{M}, \texttt{i} and \texttt{j}, etc.?

\noindent
Are you sure your algorithm works?

\noindent
What special cases have you not thought of?

\noindent
Are you sure the STL functions you use work as you think?

\noindent
Add some assertions, maybe resubmit.

\noindent
Create some testcases to run your algorithm on.

\noindent
Go through the algorithm for a simple case.

\noindent
Go through this list again.

\noindent
Explain your algorithm to a teammate.

\noindent
Ask the teammate to look at your code.

\noindent
Go for a small walk, e.g. to the toilet.

\noindent
Is your output format correct? (including whitespace)

\noindent
Rewrite your solution from the start or let a teammate do it.

\noindent
\textbf{Runtime error}

\noindent
Have you tested all corner cases locally?

\noindent
Any uninitialized variables?

\noindent
Are you reading or writing outside the range of any vector?

\noindent
Any assertions that might fail?

\noindent
Any possible division by 0? (\texttt{mod 0} for example)

\noindent
Any possible infinite recursion?

\noindent
Invalidated pointers or iterators?

\noindent
Are you using too much memory?

\noindent
Debug with resubmits (e.g. remapped signals, see Various).

\noindent
\textbf{Time limit exceeded}

\noindent
Do you have any possible infinite loops?

\noindent
What is the complexity of your algorithm?

\noindent
Are you copying a lot of unnecessary data? (use references)

\noindent
How big is the input and output? (consider \texttt{scanf} and \texttt{printf})

\noindent
Avoid \texttt{vector}, \texttt{map}. (use \texttt{array}/\texttt{unordered\_map})

\noindent
What do your teammates think about your algorithm?

\noindent
\textbf{Memory limit exceeded}

\noindent
What is the max amount of memory your algorithm should need?

\noindent
Are you clearing all data structures between test cases?
%\end{allmono}
\end{document}
